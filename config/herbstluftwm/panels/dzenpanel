#!/usr/bin/env bash
quote() {
	local q="$(printf '%q ' "$@")"
	printf '%s' "${q% }"
}

hc_quoted="$(quote "${herbstclient_command[@]:-herbstclient}")"
hc() { "${herbstclient_command[@]:-herbstclient}" "$@"; }

font="-*-tamsyn-bold-*-*-*-17-*-*-*-*-*-*-*"
glyph_font='-wuncon-siji-medium-r-normal--10-100-75-75-c-80-iso10646-1'
bgcolor='#292c2b'
selbg='#0087af'
selfg='#EFEFEF'
gray_col='#b2b2b2'
emptybg='#d70000'
fg_col='#efefef'
source "$HOME/.config/herbstluftwm/panels/get_funs.sh"
monitor=${1:-0}
geometry=($(hc monitor_rect "$monitor"))
if [ -z "$geometry" ]; then
	echo "Invalid monitor $monitor"
	exit 1
fi
# geometry has the format W H X r
pad_x=0
pad_y=0
x=$((geometry[0] + pad_x / 2))
panel_height=36
y=${geometry[3]}
y=$((y - panel_height + geometry[1] - pad_y))
panel_width=$((geometry[2] - pad_x))
pad_height=$((panel_height + pad_y))
hc pad $monitor 0 0 $pad_height 0

#$(hc get frame_border_normal_color)

####
# Try to find textwidth binary.
# In e.g. Ubuntu, this is named dzen2-textwidth.
if which textwidth &>/dev/null; then
	textwidth="textwidth"
elif which dzen2-textwidth &>/dev/null; then
	textwidth="dzen2-textwidth"
else
	echo "This script requires the textwidth tool of the dzen2 project."
	exit 1
fi
####
# true if we are using the svn version of dzen2
# depending on version/distribution, this seems to have version strings like
# "dzen-" or "dzen-x.x.x-svn"
if dzen2 -v 2>&1 | head -n 1 | grep -q '^dzen-\([^,]*-svn\|\),'; then
	dzen2_svn="true"
else
	dzen2_svn=""
fi

if awk -Wv 2>/dev/null | head -1 | grep -q '^mawk'; then
	# mawk needs "-W interactive" to line-buffer stdout correctly
	# http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=593504
	uniq_linebuffered() {
		awk -W interactive '$0 != l { print ; l=$0 ; fflush(); }' "$@"
	}
else
	# other awk versions (e.g. gawk) issue a warning with "-W interactive", so
	# we don't want to use it there.
	uniq_linebuffered() {
		awk '$0 != l { print ; l=$0 ; fflush(); }' "$@"
	}
fi


{
	### Event generator ###
	# based on different input data (mpc, date, hlwm hooks, ...) this generates events, formed like this:
	#   <eventname>\t<data> [...]
	# e.g.
	#   date    ^fg(#efefef)18:33^fg(#b2b2b2), 2013-10-^fg(#efefef)29

	#mpc idleloop player &
	while true; do
		date +$'date\t^fg()%H:%M:%S^fg(#b2b2b2) %Y-%m-^fg()%d'
		get_bat
		theme=$(hc getenv theme)
		get_ram
		$(get_temp)
		get_cpu
		sleep 0.5 || break
	done > >(uniq_linebuffered) &
	childpid=$!
	hc --idle
	kill $childpid
} 2>/dev/null | {
	IFS=$'\t' read -ra tags <<<"$(hc tag_status $monitor)"
	visible=true
	date=""
	windowtitle=""
	battery=""
	ram=""
	spotify=""
	temp=""
	while true; do

		# toggle some themes

		### Output ###
		# This part prints dzen data based on the _previous_ data handling run,
		# and then waits for the next event to happen.

		separator="^bg()^fg($selbg)|"
		left="$separator^bg()^fg(#d70000)^ca(1,$menu)<->^ca()$separator"
		# draw tags
		#draw_tags "${tags[@]}" "$selbg" "$selfg" "$emptybg" "$monitor"
		for i in "${tags[@]}"; do
			case ${i:0:1} in
			'#')
				left="$left^bg($selbg)^fg($selfg)"
				;;
			'+')
				left="$left^bg($emptybg)^fg(#ffffff)"
				;;
			':')
				left="$left^bg()^fg(#ffffff)"
				;;
			'!')
				left="$left^bg(#FF0675)^fg(#141414)"
				;;
			*)
				left=$left"^bg()^fg(#ababab)"
				;;
			esac
			# clickable tags if using SVN dzen
			left="$left^ca(1,$hc_quoted focus_monitor \"$monitor\" && "
			left="$left$hc_quoted use \"${i:1}\") ${i:1} ^ca()"
		done
		left="$left$separator"
		left="$left^bg()^fg()${windowtitle//^/^^}"
		# small adjustments
		menu="$HOME/scripts/menus/system-menu.sh"
		left="$left"
		right="^bg()$battery$ram$temp$separator$date$separator$spotify   "

		right_text_only=$(echo -n "$right" | sed 's.\^[^(]*([^)]*)..g')
		# get width of right aligned text.. and add some space..
		width=$($textwidth "$font" "$right_text_only      ")
		echo -n "$left^pa($(($panel_width - $width)))$right"
		echo

		### Data handling ###
		# This part handles the events generated in the event loop, and sets
		# internal variables based on them. The event and its arguments are
		# read into the array cmd, then action is taken depending on the event
		# name.
		# "Special" events (quit_panel/togglehidepanel/reload) are also handled
		# here.

		# wait for next event
		IFS=$'\t' read -ra cmd || break
		# find out event origin
		case "${cmd[0]}" in
		tag*)
			#echo "resetting tags" >&2
			IFS=$'\t' read -ra tags <<<"$(hc tag_status $monitor)"
			;;

		date)
			#echo "resetting date" >&2
			date="${cmd[@]:1}"
			. "$HOME/.config/herbstluftwm/panels/battery.sh" "$(get_bat)"
			. "$HOME/.config/herbstluftwm/panels/ram.sh" "$(get_ram)"
			. "$HOME/.config/herbstluftwm/panels/cpu.sh" "$(get_cpu)"
			. "$HOME/.config/herbstluftwm/panels/temp.sh" "$(get_temp)"
			if [ "$(playerctl -l | grep spotify)" ]; then
				spotify=$(. "$HOME/.config/herbstluftwm/panels/spotify.sh" "$fg_col" "$gray_col")
				spotify="^fg(#008700)^i($HOME/Pictures/icons/music.xbm)$spotify"
				spotify="^ca(2, playerctl play-pause)^ca(3, playerctl next)^ca(1, playerctl previous)$spotify^ca()^ca()^ca()          "
			else
				spotify=""
			fi

			battery="^fg($batfg)$bat_ico^fg($gray_col)$bat_num%$separator"
			ram="^fg($ram_fg)^i(/home/david/Pictures/icons/mem.xbm)^fg($gray_col)$ram_num%^fg($cpu_fg) ^i(/home/david/Pictures/icons/cpu.xbm)^fg($gray_col)$cpu_num%"
			temp="^fg($temp_fg) ^i(/home/david/Pictures/icons/temp.xbm)^fg($gray_col)"$temp_num"C"
			;;
		quit_panel)
			exit
			;;
		togglehidepanel)
			currentmonidx=$(hc list_monitors | sed -n '/\[FOCUS\]$/s/:.*//p')
			if [ "${cmd[1]}" -ne "$monitor" ]; then
				continue
			fi
			if [ "${cmd[1]}" = "current" ] && [ "$currentmonidx" -ne "$monitor" ]; then
				continue
			fi
			echo "^togglehide()"
			if $visible; then
				visible=false
				hc pad $monitor 0
			else
				visible=true
				hc pad $monitor $panel_height
			fi
			;;
		reload)
			exit
			;;
		focus_changed | window_title_changed)
			windowtitle="${cmd[@]:2}"
			;;
			#player)
			#    ;;
		esac
	done

	### dzen2 ###
	# After the data is gathered and processed, the output of the previous block
	# gets piped to dzen2.
	hc unlock

} \
	2>/dev/null | dzen2 -w $panel_width -x $x -y $y -fn "$font" -h $panel_height \
	-e "button3=exec;button4=exec:$hc_quoted use_index -1;button5=exec:$hc_quoted use_index +1;entertitle=uncollapse;enterslave=grabkeys;leaveslave=collapse,ungrabkeys;" \
	-ta l -bg "$bgcolor" -fg "$fg_col"
